<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Project Arbor - LocalStorage, Global Drag ID</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      user-select: none; 
    }

    h1 {
      margin-bottom: 0.5em;
    }

    /* Regi√£o para adicionar tarefas no root (quando n√£o h√° item selecionado ou lista vazia) */
    .root-input-area {
      position: absolute;
      height: 2em;
      z-index: 1;
    }

    ul {
      list-style: none;
      margin-left: 0;
      padding-left: 20px; /* indent b√°sico */
    }

    li {
      margin: 0.25em 0;
    }

    /* Reset positioning */
    .task-container {
      position: relative;
      padding-left: 24px; /* Space for status emoji */
      line-height: 24px;
    }

    /* Status emoji */
    .task-container::before {
      content: "üå±";
      position: absolute;
      left: 2px;
      cursor: pointer;
    }

    /* Expand button */
    .expand-button {
      position: absolute;
      left: -20px; /* Adjust if needed to align properly */
      top: 50%;
      cursor: pointer;
    }

    /* Task row should be relative to allow proper stacking */
    .task-row {
      position: relative;
      width: 100%;
    }

    /* Hover b√°sico */
    .task-container:hover {
      background-color: #f8f8f8;
    }

    /* Selec√ß√£o do item */
    .task-container.selected {
      outline: 2px solid #007BFF;
      border-radius: 3px;
    }

    /* Destaque para ancestrais do selecionado */
    .task-container.ancestor-of-selected {
      background-color: #e3f2e3;
      border-radius: 3px;
      margin-left: -5px;
    }

    /* Destaque quando √© um alvo de drop v√°lido */
    .task-container.drag-hover {
      border: 2px dashed #007BFF;
      background-color: #ccf2ff;
    }

    /* Bot√£o de expandir/recolher com posicionamento absoluto do seu jeito */
    .toggle-btn {
      position: absolute;
      margin-left: -37px;
      font-size: 0.9em;
      cursor: pointer;
    }
    .toggle-placeholder {
      position: absolute;
      margin-left: -5%;
      width: 30px;
    }

    /* Input √∫nico de texto */
    #singleInput {
      border: 1px solid #888;
      border-radius: 3px;
      padding: 2px 4px;
      font-size: 0.9em;
      width: 150px;
      margin-left: 8px;
      box-sizing: border-box; /* Include padding and border in element's total width */
    }

    #exportBtn {
      margin-bottom: 1em;
      position: relative;
      z-index: 2;
    }

    /* Destaque quando solta no root */
    .root-drop-target {
      outline: 2px dashed #007BFF;
      min-height: 20px;
      margin: 10px 0;
      background-color: #eef9ff;
      transition: background-color 0.2s;
    }

    .task-container::before:hover {
      background-color: #f0f0f0;
    }

    .task-container[data-status="blooming"]::before {
      content: "üå∏";
    }

    .task-container[data-status="needs-water"]::before {
      content: "üíß";
    }

    .task-container[data-status="under-sun"]::before {
      content: "‚òÄÔ∏è";
    }

    .task-container[data-status="harvest"]::before {
      content: "üåæ";
    }

    .task-container[data-status="dormant"]::before {
      content: "üí§";
    }

    .task-container[data-status="pruned"]::before {
      content: "‚úÇÔ∏è";
    }

    #treeRoot {
      position: relative;
      z-index: 1;
      margin-top: 3em; /* Add margin to create space for the root input */
    }

    /* When there's no selection or items, remove the margin */
    #treeRoot:empty {
      margin-top: 0;
    }
  </style>
</head>
<body>

<h1>Project Arbor</h1>

<button id="exportBtn">Export as JSON</button>
<div id="rootInputContainer" class="root-input-area"></div>
<ul id="treeRoot"></ul>

<script>
  /*********************************************************************
   *                         ESTADO & VARI√ÅVEIS
   *********************************************************************/
  let tasks = [];          // Lista de tarefas no root
  let taskMap = {};        // Mapa de ID -> objeto da tarefa
  let selectedTaskId = null;
  let draftText = "";
  
  const LS_KEY = "arbor_tasks";
  
  // Ao inv√©s de usar dataTransfer para armazenar o ID,
  // usaremos essa vari√°vel global para contornar problemas de browsers.
  let draggingItemId = null; 

  const STATUSES = ['seed', 'blooming', 'needs-water', 'under-sun', 'harvest', 'dormant', 'pruned'];

  // Add a new constant for the selection storage key
  const LS_SELECTION_KEY = "arbor_selection";

  // Add constants for meta storage
  const LS_META_KEY = "arbor_meta";

  // Global meta state
  let metaState = {
    selectedTaskId: null,
    draggingItemId: null,
    draftText: ""
  };

  /**
   * Returns an array of all ancestor IDs (parent, grandparent, etc.)
   * for a given task ID, in order from immediate parent up.
   */
  function getAncestorIds(taskId) {
    const result = [];
    let current = taskMap[taskId];
    while (current && current.parentId) {
      result.push(current.parentId);
      current = taskMap[current.parentId];
    }
    return result;
  }

  /*********************************************************************
   *                      FUN√á√ïES DE LOCALSTORAGE
   *********************************************************************/
  function saveToLocalStorage() {
    const json = JSON.stringify(tasks);
    localStorage.setItem(LS_KEY, json);
  }

  function loadFromLocalStorage() {
    const stored = localStorage.getItem(LS_KEY);
    if (!stored) {
      tasks = [];
      taskMap = {};
      return;
    }
    try {
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed)) {
        tasks = cleanupDataStructure(parsed);
      } else {
        tasks = [];
      }
    } catch {
      tasks = [];
    }
    taskMap = {};
    rebuildTaskMap(tasks);
  }

  function rebuildTaskMap(list) {
    for (const t of list) {
      taskMap[t.id] = t;
      if (Array.isArray(t.children) && t.children.length > 0) {
        rebuildTaskMap(t.children);
      }
    }
  }

  function saveMetaState() {
    localStorage.setItem(LS_META_KEY, JSON.stringify(metaState));
  }

  function loadMetaState() {
    const stored = localStorage.getItem(LS_META_KEY);
    if (!stored) return;
    
    try {
      const parsed = JSON.parse(stored);
      metaState = {
        ...metaState,  // Keep defaults
        ...parsed      // Override with stored values
      };
      
      // Restore global variables from meta state
      selectedTaskId = metaState.selectedTaskId;
      draggingItemId = metaState.draggingItemId;
      draftText = metaState.draftText;
      
      // Validate that selected task still exists
      if (selectedTaskId && !taskMap[selectedTaskId]) {
        selectedTaskId = null;
        metaState.selectedTaskId = null;
        saveMetaState();
      }
    } catch (e) {
      console.error('Error loading meta state:', e);
    }
  }

  /*********************************************************************
   *                      CRIA√á√ÉO & MODIFICA√á√ÉO
   *********************************************************************/
  function createTask(text, parentId = null) {
    const task = {
      id: crypto.randomUUID(),
      text,
      modified: Date.now()
    };
    
    // Only add parentId if it exists
    if (parentId) {
      task.parentId = parentId;
    }
    
    taskMap[task.id] = task;
    return task;
  }

  function addTopLevelTask(text) {
    const t = createTask(text, null);
    tasks.push(t);
    saveToLocalStorage();
    return t;
  }

  function addChildTask(parentId, text) {
    const parent = taskMap[parentId];
    if (!parent) return null;
    
    const child = createTask(text, parentId);
    
    // Create children array only when needed
    if (!parent.children) {
      parent.children = [];
    }
    parent.children.push(child);
    
    // Remove collapsed state if it exists
    delete parent.collapsed;
    
    saveToLocalStorage();
    return child;
  }

  function addSiblingTask(taskId, text) {
    const task = taskMap[taskId];
    if (!task) return null;
    const parentId = task.parentId;
    const newTask = createTask(text, parentId);

    if (parentId === null) {
      // Irm√£o top-level
      const idx = tasks.indexOf(task);
      if (idx < 0) {
        tasks.push(newTask);
      } else {
        tasks.splice(idx + 1, 0, newTask);
      }
    } else {
      const parent = taskMap[parentId];
      if (!parent) return null;
      const idx = parent.children.indexOf(task);
      if (idx < 0) {
        parent.children.push(newTask);
      } else {
        parent.children.splice(idx + 1, 0, newTask);
      }
    }
    saveToLocalStorage();
    return newTask;
  }

  function deleteTask(taskId) {
    const task = taskMap[taskId];
    if (!task) return;

    const nextSelectedId = findNextTaskToSelect(taskId);
    
    // Remove from parent or root
    if (task.parentId === null) {
      tasks = tasks.filter(t => t.id !== taskId);
    } else {
      const p = taskMap[task.parentId];
      if (p) {
        p.children = p.children.filter(c => c.id !== taskId);
        // If last child was removed, delete the children array
        if (p.children.length === 0) {
          delete p.children;
        }
      }
    }
    
    removeFromMap(task);
    updateSelection(nextSelectedId);
    updateDraftText("");
    saveToLocalStorage();
  }

  function findNextTaskToSelect(taskId) {
    const task = taskMap[taskId];
    if (!task) return null;
    
    const visible = buildVisibleList();
    const currentIndex = visible.findIndex(t => t.id === taskId);
    
    if (currentIndex === -1) return null;
    
    // If this is the only child, select the parent
    if (task.parentId && taskMap[task.parentId]?.children?.length === 1) {
      return task.parentId;
    }
    
    // Try to select previous sibling
    if (currentIndex > 0) {
      return visible[currentIndex - 1].id;
    }
    
    // If no previous sibling, try next sibling
    if (currentIndex < visible.length - 1) {
      return visible[currentIndex + 1].id;
    }
    
    // If no siblings, select parent
    if (task.parentId) {
      return task.parentId;
    }
    
    // If no parent (root level), return null
    return null;
  }

  function removeFromMap(task) {
    for (const child of task.children) {
      removeFromMap(child);
    }
    delete taskMap[task.id];
  }

  function toggleTaskExpand(taskId) {
    const t = taskMap[taskId];
    if (!t || !t.children?.length) return;
    
    if (t.collapsed) {
      delete t.collapsed;
    } else {
      t.collapsed = true;
    }
    
    updateSelection(taskId);
    t.modified = Date.now(); // Update modification time when collapsing/expanding
    saveToLocalStorage();
  }

  function cycleTaskStatus(taskId) {
    const task = taskMap[taskId];
    if (!task) return;
    
    const currentIdx = STATUSES.indexOf(task.status || 'seed');
    const newStatus = STATUSES[(currentIdx + 1) % STATUSES.length];
    
    // Only store non-default status
    if (newStatus === 'seed') {
      delete task.status;
    } else {
      task.status = newStatus;
    }
    
    task.modified = Date.now();
    saveToLocalStorage();
  }

  /*********************************************************************
   *                    DRAG & DROP (VAR GLOBAL)
   *********************************************************************/
  function reparentTask(childId, newParentId) {
    if (!taskMap[childId]) return;
    // Evitar loops
    if (newParentId !== null && isAncestorOrSelf(newParentId, childId)) return;

    // Remover do antigo parent ou root
    const child = taskMap[childId];
    if (child.parentId === null) {
      tasks = tasks.filter(t => t.id !== childId);
    } else {
      const oldParent = taskMap[child.parentId];
      if (oldParent) {
        oldParent.children = oldParent.children.filter(c => c.id !== childId);
        // If last child was removed, delete the children array
        if (oldParent.children.length === 0) {
          delete oldParent.children;
        }
      }
    }

    // Inserir no novo parent ou root
    if (newParentId === null) {
      child.parentId = null;
      tasks.push(child);
    } else {
      const newParent = taskMap[newParentId];
      if (!newParent) return; // Se for inv√°lido, n√£o faz nada
      
      child.parentId = newParentId;
      if (!newParent.children) {
        newParent.children = [];
      }
      newParent.children.push(child);
    }
    
    // Update modification time
    child.modified = Date.now();
    
    // Seleciona o item
    updateSelection(childId);
    saveToLocalStorage();
    renderAll();
  }

  function isAncestorOrSelf(targetId, maybeChildId) {
    if (targetId === maybeChildId) return true;
    let c = taskMap[maybeChildId];
    while (c && c.parentId) {
      if (c.parentId === targetId) return true;
      c = taskMap[c.parentId];
    }
    return false;
  }

  /*********************************************************************
   *                      NAVEGA√á√ÉO
   *********************************************************************/
  function buildVisibleList() {
    const out = [];
    function dfs(arr) {
      for (const t of arr) {
        out.push(t);
        if (!t.collapsed && t.children?.length) {
          dfs(t.children);
        }
      }
    }
    dfs(tasks);
    return out;
  }

  function selectNextTask() {
    const visible = buildVisibleList();
    if (!visible.length) return;
    if (selectedTaskId === null) {
      updateSelection(visible[0].id);
    } else {
      const idx = visible.findIndex(t => t.id === selectedTaskId);
      if (idx < 0) {
        updateSelection(visible[0].id);
      } else if (idx < visible.length - 1) {
        updateSelection(visible[idx + 1].id);
      }
    }
  }

  function selectPrevTask() {
    const visible = buildVisibleList();
    if (!visible.length) return;
    if (selectedTaskId === null) {
      updateSelection(visible[visible.length - 1].id);
    } else {
      const idx = visible.findIndex(t => t.id === selectedTaskId);
      if (idx < 0) {
        updateSelection(visible[0].id);
      } else if (idx === 0) {
        updateSelection(null);
      } else {
        updateSelection(visible[idx - 1].id);
      }
    }
  }

  function selectFirstChild(taskId) {
    if (taskId === null) return;
    const t = taskMap[taskId];
    if (!t) return;
    if (!t.collapsed) {
      t.collapsed = true;
      saveToLocalStorage();
    }
    if (t.children?.length) {
      updateSelection(t.children[0].id);
    }
  }

  function selectParentOrCollapse(taskId) {
    if (taskId === null) return;
    const t = taskMap[taskId];
    if (!t) return;
    if (t.collapsed && t.children?.length) {
      t.collapsed = false;
      saveToLocalStorage();
    } else if (t.parentId) {
      updateSelection(t.parentId);
    } else {
      updateSelection(null);
    }
  }

  /*********************************************************************
   *                       RENDERIZA√á√ÉO
   *********************************************************************/
  const rootInputContainerEl = document.getElementById("rootInputContainer");
  const treeRootEl = document.getElementById("treeRoot");
  function renderAll() {
    rootInputContainerEl.innerHTML = "";
    treeRootEl.innerHTML = "";

    if (!tasks.length || selectedTaskId === null) {
      renderRootInput();
    }

    tasks.forEach(t => {
      renderTask(t, treeRootEl);
    });
  }

  function renderRootInput() {
    const inputEl = document.createElement("input");
    inputEl.id = "singleInput";
    inputEl.value = draftText;
    inputEl.placeholder = "Digite para adicionar ao root...";
    inputEl.onkeydown = handleSingleInputKeyDown;
    inputEl.oninput = handleInputChange;
    setTimeout(() => inputEl.focus(), 0);
    rootInputContainerEl.appendChild(inputEl);

    // Permitir drop no root
    rootInputContainerEl.addEventListener("dragover", e => e.preventDefault());
    rootInputContainerEl.addEventListener("dragenter", e => {
      e.preventDefault();
      rootInputContainerEl.classList.add("root-drop-target");
    });
    rootInputContainerEl.addEventListener("dragleave", e => {
      rootInputContainerEl.classList.remove("root-drop-target");
    });
    rootInputContainerEl.addEventListener("drop", e => {
      e.preventDefault();
      rootInputContainerEl.classList.remove("root-drop-target");
      if (draggingItemId) {
        reparentTask(draggingItemId, null);
      }
    });
  }

  function renderTask(task, containerEl) {
    const li = document.createElement("li");
    const row = document.createElement("div");
    row.className = "task-container";
    
    // DRAG & DROP 
    row.draggable = true;
    
    // dragstart => set global draggingItemId
    row.addEventListener("dragstart", e => {
      handleDragStart(e, task.id);
    });

    // dragend => clear global
    row.addEventListener("dragend", e => {
      handleDragEnd(e);
    });

    // Move these event listeners to the li element instead of the row
    li.addEventListener("dragenter", e => {
      e.preventDefault();
      if (draggingItemId && draggingItemId !== task.id && !isAncestorOrSelf(task.id, draggingItemId)) {
        row.classList.add("drag-hover");
      }
    });

    li.addEventListener("dragover", e => {
      e.preventDefault();
      // Ensure hover state stays while dragging over
      if (draggingItemId && draggingItemId !== task.id && !isAncestorOrSelf(task.id, draggingItemId)) {
        row.classList.add("drag-hover");
      }
    });

    li.addEventListener("dragleave", e => {
      // Only remove if we're actually leaving the li element
      if (!li.contains(e.relatedTarget)) {
        row.classList.remove("drag-hover");
      }
    });

    li.addEventListener("drop", e => {
      e.preventDefault();
      e.stopPropagation();
      row.classList.remove("drag-hover");
      if (draggingItemId && draggingItemId !== task.id && !isAncestorOrSelf(task.id, draggingItemId)) {
        reparentTask(draggingItemId, task.id);
      }
    });

    // Sele√ß√£o & ancestrais
    if (selectedTaskId === task.id) {
      row.classList.add("selected");
    }
    const ancestors = getAncestorIds(selectedTaskId);
    if (ancestors.includes(task.id)) {
      row.classList.add("ancestor-of-selected");
    }

    // Toggle ou placeholder
    if (task.children?.length) {
      const toggle = document.createElement("span");
      toggle.className = "toggle-btn";
      toggle.textContent = task.collapsed ? "[+]" : "[-]";
      toggle.onclick = e => {
        e.stopPropagation();
        toggleTaskExpand(task.id);
        renderAll();
      };
      row.appendChild(toggle);
    } else {
      const placeholder = document.createElement("span");
      placeholder.className = "toggle-placeholder";
      row.appendChild(placeholder);
    }

    // Label
    const labelSpan = document.createElement("span");
    labelSpan.textContent = task.text;
    labelSpan.onclick = e => {
      e.stopPropagation();
      updateSelection(task.id);
      updateDraftText("");
      renderAll();
    };
    row.appendChild(labelSpan);

    // Se for o item selecionado, exibir input
    if (selectedTaskId === task.id) {
      const inputEl = document.createElement("input");
      inputEl.id = "singleInput";
      inputEl.value = draftText;
      inputEl.onkeydown = handleSingleInputKeyDown;
      inputEl.oninput = handleInputChange;
      inputEl.onclick = e => e.stopPropagation();
      setTimeout(() => inputEl.focus(), 0);
      row.appendChild(inputEl);
    }

    row.setAttribute('data-status', task.status || 'seed');
    
    // Add click handler directly to the row's ::before pseudo-element area
    row.addEventListener('click', e => {
      // Check if click was in the first 30px (emoji area)
      if (e.offsetX < 30) {
        e.stopPropagation();
        cycleTaskStatus(task.id);
        renderAll();
      }
    });

    li.appendChild(row);

    // Renderizar filhos se expandido
    if (!task.collapsed && task.children?.length) {
      const childUl = document.createElement("ul");
      task.children.forEach(c => renderTask(c, childUl));
      li.appendChild(childUl);
    }

    containerEl.appendChild(li);
  }

  function handleSingleInputKeyDown(e) {
    const text = metaState.draftText.trim();
    if (e.key === "Enter") {
      e.preventDefault();
      if (!text) return;
      if (metaState.selectedTaskId === null) {
        const newTask = addTopLevelTask(text);
        updateSelection(newTask.id);
      } else {
        const newTask = addChildTask(metaState.selectedTaskId, text);
        if (newTask) {
          updateSelection(newTask.id);
        }
      }
      updateDraftText("");
      renderAll();
    }
    else if (e.key === "Tab") {
      e.preventDefault();
      if (!text) return;
      if (metaState.selectedTaskId === null) {
        const newTask = addTopLevelTask(text);
        updateSelection(newTask.id);
      } else {
        const newTask = addSiblingTask(metaState.selectedTaskId, text);
        if (newTask) {
          updateSelection(newTask.id);
        }
      }
      updateDraftText("");
      renderAll();
    }
    else if (e.key === "ArrowDown") {
      e.preventDefault();
      selectNextTask();
      renderAll();
    }
    else if (e.key === "ArrowUp") {
      e.preventDefault();
      selectPrevTask();
      renderAll();
    }
    else if (e.key === "ArrowRight") {
      e.preventDefault();
      selectFirstChild(metaState.selectedTaskId);
      renderAll();
    }
    else if (e.key === "ArrowLeft") {
      e.preventDefault();
      selectParentOrCollapse(metaState.selectedTaskId);
      renderAll();
    }
  }

  function handleInputChange(e) {
    updateDraftText(e.target.value);
  }

  /*********************************************************************
   *         TECLA DELETE => DELETAR ITEM SELECIONADO
   *********************************************************************/
  document.addEventListener("keydown", e => {
    if (e.key === "Delete") {
      if (selectedTaskId !== null) {
        deleteTask(selectedTaskId);
        selectedTaskId = null;
        draftText = "";
        renderAll();
      }
    }
  });

  /*********************************************************************
   *         CLIQUE FORA => DESELECIONAR
   *********************************************************************/
  document.addEventListener("click", e => {
    const isInsideTree = treeRootEl.contains(e.target);
    const isInsideRoot = rootInputContainerEl.contains(e.target);
    if (!isInsideTree && !isInsideRoot) {
      updateSelection(null);
      updateDraftText("");
      renderAll();
    }
  });

  /*********************************************************************
   *        DROP NO BODY => RE-PARENT PARA ROOT
   *********************************************************************/
  document.addEventListener("dragover", e => e.preventDefault());
  document.addEventListener("drop", e => {
    e.preventDefault();
    // Se n√£o foi tratado por um filho, cair√° aqui
    if (draggingItemId) {
      reparentTask(draggingItemId, null);
    }
  });

  /*********************************************************************
   *            EXPORTAR COMO JSON
   *********************************************************************/
  const exportBtn = document.getElementById("exportBtn");
  exportBtn.onclick = () => {
    const json = JSON.stringify(tasks, null, 2);
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(json);
    const dlAnchor = document.createElement("a");
    dlAnchor.setAttribute("href", dataStr);
    dlAnchor.setAttribute("download", "tasks.json");
    dlAnchor.click();
  };

  /*********************************************************************
   *            INICIALIZA√á√ÉO
   *********************************************************************/
  function init() {
    loadFromLocalStorage();
    loadMetaState();
    renderAll();
  }

  // Call init instead of separate load/render calls
  init();

  // Add this to help debug
  window.addEventListener('load', () => {
    console.log('After load - selectedTaskId:', selectedTaskId);
    console.log('localStorage selection:', localStorage.getItem(LS_SELECTION_KEY));
  });

  // Add this function to clean up the data structure
  function cleanupDataStructure(tasks) {
    const now = Date.now();
    
    function cleanTask(task) {
      // Create new object with only necessary properties
      const cleaned = {
        id: task.id,
        text: task.text,
        modified: task.modified || now  // Ensure modified always exists
      };
      
      // Only add parentId if not at root
      if (task.parentId) {
        cleaned.parentId = task.parentId;
      }
      
      // Only add children if they exist and not empty
      if (task.children?.length > 0) {
        cleaned.children = task.children.map(cleanTask);
        // Preserve collapsed state
        if (task.collapsed) {
          cleaned.collapsed = true;
        }
      }
      
      // Only add status if not 'seed'
      if (task.status && task.status !== 'seed') {
        cleaned.status = task.status;
      }
      
      return cleaned;
    }
    
    return tasks.map(cleanTask);
  }

  // Update drag handlers to use meta state
  function handleDragStart(e, taskId) {
    metaState.draggingItemId = taskId;
    draggingItemId = taskId;
    saveMetaState();
  }

  function handleDragEnd(e) {
    metaState.draggingItemId = null;
    draggingItemId = null;
    saveMetaState();
    // Clear any stuck hover states
    document.querySelectorAll('.drag-hover').forEach(el => el.classList.remove('drag-hover'));
  }

  // Update selection handlers
  function updateSelection(taskId) {
    selectedTaskId = taskId;
    metaState.selectedTaskId = taskId;
    saveMetaState();
  }

  // Update draft text handler
  function updateDraftText(text) {
    draftText = text;
    metaState.draftText = text;
    saveMetaState();
  }
</script>

</body>
</html>
