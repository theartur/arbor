<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Project Arbor - LocalStorage, Global Drag ID</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      user-select: none; 
    }

    h1 {
      margin-bottom: 0.5em;
    }

    /* Regi√£o para adicionar tarefas no root (quando n√£o h√° item selecionado ou lista vazia) */
    .root-input-area {
      position: absolute;
      height: 2em;
      z-index: 1;
    }

    ul {
      list-style: none;
      margin-left: 0;
      padding-left: 20px; /* indent b√°sico */
    }

    li {
      margin: 0.25em 0;
    }

    /* Reset positioning */
    .item-container {
      position: relative;
      padding-left: 24px; /* Space for status emoji */
      line-height: 24px;
    }

    /* Status emoji */
    .item-container::before {
      content: "üå±";
      position: absolute;
      left: 2px;
      cursor: pointer;
    }

    /* Expand button */
    .expand-button {
      position: absolute;
      left: -20px; /* Adjust if needed to align properly */
      top: 50%;
      cursor: pointer;
    }

    /* Item row should be relative to allow proper stacking */
    .item-row {
      position: relative;
      width: 100%;
    }

    /* Hover b√°sico */
    .item-container:hover {
      background-color: #f8f8f8;
    }

    /* Selec√ß√£o do item */
    .item-container.selected {
      outline: 2px solid #007BFF;
      border-radius: 3px;
    }

    /* Destaque para ancestrais do selecionado */
    .item-container.ancestor-of-selected {
      background-color: #e3f2e3;
      border-radius: 3px;
      margin-left: -5px;
    }

    /* Destaque quando √© um alvo de drop v√°lido */
    .item-container.drag-hover {
      border: 2px dashed #007BFF;
      background-color: #ccf2ff;
    }

    /* Bot√£o de expandir/recolher com posicionamento absoluto do seu jeito */
    .toggle-btn {
      position: absolute;
      margin-left: -37px;
      font-size: 0.9em;
      cursor: pointer;
    }
    .toggle-placeholder {
      position: absolute;
      margin-left: -5%;
      width: 30px;
    }

    /* Input √∫nico de texto */
    #singleInput {
      border: 1px solid #888;
      border-radius: 3px;
      padding: 2px 4px;
      font-size: 0.9em;
      width: 150px;
      margin-left: 8px;
      box-sizing: border-box; /* Include padding and border in element's total width */
    }

    #exportBtn {
      margin-bottom: 1em;
      position: relative;
      z-index: 2;
    }

    /* Destaque quando solta no root */
    .root-drop-target {
      outline: 2px dashed #007BFF;
      min-height: 20px;
      margin: 10px 0;
      background-color: #eef9ff;
      transition: background-color 0.2s;
    }

    .item-container::before:hover {
      background-color: #f0f0f0;
    }

    .item-container[data-status="blooming"]::before {
      content: "üå∏";
    }

    .item-container[data-status="needs-water"]::before {
      content: "üíß";
    }

    .item-container[data-status="under-sun"]::before {
      content: "‚òÄÔ∏è";
    }

    .item-container[data-status="harvest"]::before {
      content: "üåæ";
    }

    .item-container[data-status="dormant"]::before {
      content: "üí§";
    }

    .item-container[data-status="pruned"]::before {
      content: "‚úÇÔ∏è";
    }

    #treeRoot {
      position: relative;
      z-index: 1;
      margin-top: 3em; /* Add margin to create space for the root input */
    }

    /* When there's no selection or items, remove the margin */
    #treeRoot:empty {
      margin-top: 0;
    }

    /* Add these new styles */
    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      opacity: 1;
      transition: opacity 0.15s ease-in-out;
    }

    .context-dialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      min-width: 300px;
      max-width: 80vw;
      max-height: 80vh;
      overflow-y: auto;
    }

    .dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      padding: 0.2em 0.5em;
    }

    .close-button:hover {
      background: #f0f0f0;
      border-radius: 4px;
    }

    /* Estilo para o handle de drag & drop */
    .drag-handle {
        cursor: move;
        padding: 0 8px;
        color: #999;
        font-size: 14px;
        user-select: none;
        display: inline-block;
        vertical-align: middle;
        visibility: hidden;  /* Esconde por padr√£o */
    }

    /* Mostra o handle quando hover sobre o container */
    .item-container:hover .drag-handle {
        visibility: visible;
    }

    /* Permite sele√ß√£o de texto no label */
    .item-label {
        user-select: text;
        cursor: text;
        flex: 1;
    }

    /* Atualiza o item-container para usar flexbox */
    .item-container {
        display: flex;
        align-items: center;
        padding-left: 24px;
        line-height: 24px;
        user-select: text;
    }
  </style>
</head>
<body>

<h1>Project Arbor</h1>

<button id="exportBtn">Export as JSON</button>
<div id="rootInputContainer" class="root-input-area"></div>
<ul id="treeRoot"></ul>

<script>
  /*********************************************************************
   *                         ESTADO & VARI√ÅVEIS
   *********************************************************************/
  // Add data source abstraction first
  const DataSource = {
    async save(key, data) {
      // For now, use localStorage
      localStorage.setItem(key, JSON.stringify(data));
    },
    
    async load(key) {
      // For now, use localStorage
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    }
  };

  let items = [];          // Lista de tarefas no root
  let itemMap = {};        // Mapa de ID -> objeto da tarefa
  let selectedItemId = null;
  let draftValue = "";
  
  const LS_KEY = "arbor_items";
  
  // Ao inv√©s de usar dataTransfer para armazenar o ID,
  // usaremos essa vari√°vel global para contornar problemas de browsers.
  let draggingItemId = null; 

  const STATUSES = ['seed', 'blooming', 'needs-water', 'under-sun', 'harvest', 'dormant', 'pruned'];

  // Add a new constant for the selection storage key
  const LS_SELECTION_KEY = "arbor_selection";

  // Add constants for meta storage
  const LS_META_KEY = "arbor_meta";

  // Global meta state
  let metaState = {
    selectedItemId: null,
    draggingItemId: null,
    draftValue: ""
  };

  // Add currentProjectId to state
  let currentProjectId = 'default';

  /**
   * Returns an array of all ancestor IDs (parent, grandparent, etc.)
   * for a given item ID, in order from immediate parent up.
   */
  function getAncestorIds(itemId) {
    const result = [];
    let current = itemMap[itemId];
    while (current && current.parentId) {
      result.push(current.parentId);
      current = itemMap[current.parentId];
    }
    return result;
  }

  /*********************************************************************
   *                      FUN√á√ïES DE LOCALSTORAGE
   *********************************************************************/
  function saveToLocalStorage() {
    const json = JSON.stringify(items);
    localStorage.setItem(LS_KEY, json);
  }

  function loadFromLocalStorage() {
    const stored = localStorage.getItem(LS_KEY);
    if (!stored) {
      items = [];
      itemMap = {};
      return;
    }
    try {
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed)) {
        items = cleanupDataStructure(parsed);
      } else {
        items = [];
      }
    } catch {
      items = [];
    }
    itemMap = {};
    rebuildItemMap(items);
  }

  function rebuildItemMap(list) {
    for (const t of list) {
      itemMap[t.id] = t;
      if (Array.isArray(t.children) && t.children.length > 0) {
        rebuildItemMap(t.children);
      }
    }
  }

  function saveMetaState() {
    localStorage.setItem(LS_META_KEY, JSON.stringify(metaState));
  }

  function loadMetaState() {
    const stored = localStorage.getItem(LS_META_KEY);
    if (!stored) return;
    
    try {
      const parsed = JSON.parse(stored);
      metaState = {
        ...metaState,  // Keep defaults
        ...parsed      // Override with stored values
      };
      
      // Restore global variables from meta state
      selectedItemId = metaState.selectedItemId;
      draggingItemId = metaState.draggingItemId;
      draftValue = metaState.draftValue;
      
      // Validate that selected item still exists
      if (selectedItemId && !itemMap[selectedItemId]) {
        selectedItemId = null;
        metaState.selectedItemId = null;
        saveMetaState();
      }
    } catch (e) {
      console.error('Error loading meta state:', e);
    }
  }

  /*********************************************************************
   *                      CRIA√á√ÉO & MODIFICA√á√ÉO
   *********************************************************************/
  function createItem(value, parentId = null, type = 'actionable') {
    const item = {
      id: crypto.randomUUID(),
      value,
      modified: Date.now(),
      type,
      tldr: '',        // Brief description
      details: '',     // Detailed information
      parentId
    };
    
    if (parentId) {
      item.parentId = parentId;
    }
    
    itemMap[item.id] = item;
    return item;
  }

  function addTopLevelItem(value) {
    const t = createItem(value, null);
    items.push(t);
    saveToLocalStorage();
    return t;
  }

  function addChildItem(parentId, value) {
    const parent = itemMap[parentId];
    if (!parent) return null;
    
    const child = createItem(value, parentId);
    
    // Create children array only when needed
    if (!parent.children) {
      parent.children = [];
    }
    parent.children.push(child);
    
    // Remove collapsed state if it exists
    delete parent.collapsed;
    
    saveToLocalStorage();
    return child;
  }

  function addSiblingItem(itemId, value) {
    const item = itemMap[itemId];
    if (!item) return null;
    const parentId = item.parentId;
    const newItem = createItem(value, parentId);

    if (parentId === null) {
      // Irm√£o top-level
      const idx = items.indexOf(item);
      if (idx < 0) {
        items.push(newItem);
      } else {
        items.splice(idx + 1, 0, newItem);
      }
    } else {
      const parent = itemMap[parentId];
      if (!parent) return null;
      const idx = parent.children.indexOf(item);
      if (idx < 0) {
        parent.children.push(newItem);
      } else {
        parent.children.splice(idx + 1, 0, newItem);
      }
    }
    saveToLocalStorage();
    return newItem;
  }

  function findNextItemToSelect(itemId) {
    const item = itemMap[itemId];
    if (!item) return null;
    
    // If this item has a parent and is the only child, select the parent
    if (item.parentId) {
        const parent = itemMap[item.parentId];
        if (parent && (!parent.children || parent.children.length <= 1)) {
            return parent.id;
        }
    }
    
    const visible = buildVisibleList();
    const currentIndex = visible.findIndex(t => t.id === itemId);
    
    if (currentIndex === -1) return null;
    
    // Try to select previous sibling
    if (currentIndex > 0) {
        return visible[currentIndex - 1].id;
    }
    
    // If no previous sibling, try next sibling
    if (currentIndex < visible.length - 1) {
        return visible[currentIndex + 1].id;
    }
    
    // If no siblings and has parent, select parent
    if (item.parentId) {
        return item.parentId;
    }
    
    // If no parent (root level), return null
    return null;
  }

  function deleteItem(itemId) {
    const item = itemMap[itemId];
    if (!item) return;

    const nextSelectedId = findNextItemToSelect(itemId);
    
    // Remove from parent or root
    if (item.parentId === null) {
        items = items.filter(t => t.id !== itemId);
    } else {
        const p = itemMap[item.parentId];
        if (p) {
            p.children = p.children.filter(c => c.id !== itemId);
            // If last child was removed, delete the children array
            if (p.children.length === 0) {
                delete p.children;
            }
        }
    }
    
    removeFromMap(item);
    
    // Only update draft value if we're not selecting a new item
    if (!nextSelectedId) {
        updateDraftValue("");
    }
    
    // Update selection before saving and rendering
    updateSelection(nextSelectedId);
    saveToLocalStorage();
    renderAll();
  }

  function removeFromMap(item) {
    // S√≥ tenta remover filhos se eles existirem
    if (item.children?.length) {
        for (const child of item.children) {
            removeFromMap(child);
        }
    }
    delete itemMap[item.id];
  }

  function toggleItemExpand(itemId) {
    const t = itemMap[itemId];
    if (!t || !t.children?.length) return;
    
    if (t.collapsed) {
      delete t.collapsed;
    } else {
      t.collapsed = true;
    }
    
    updateSelection(itemId);
    t.modified = Date.now(); // Update modification time when collapsing/expanding
    saveToLocalStorage();
  }

  function cycleItemStatus(itemId) {
    const item = itemMap[itemId];
    if (!item) return;
    
    const currentIdx = STATUSES.indexOf(item.status || 'seed');
    const newStatus = STATUSES[(currentIdx + 1) % STATUSES.length];
    
    // Only store non-default status
    if (newStatus === 'seed') {
      delete item.status;
    } else {
      item.status = newStatus;
    }
    
    item.modified = Date.now();
    saveToLocalStorage();
  }

  /*********************************************************************
   *                    DRAG & DROP (VAR GLOBAL)
   *********************************************************************/
  function reparentItem(childId, newParentId) {
    if (!itemMap[childId]) return;
    // Evitar loops
    if (newParentId !== null && isAncestorOrSelf(newParentId, childId)) return;

    // Remover do antigo parent ou root
    const child = itemMap[childId];
    if (child.parentId === null) {
      items = items.filter(t => t.id !== childId);
    } else {
      const oldParent = itemMap[child.parentId];
      if (oldParent) {
        oldParent.children = oldParent.children.filter(c => c.id !== childId);
        // If last child was removed, delete the children array
        if (oldParent.children.length === 0) {
          delete oldParent.children;
        }
      }
    }

    // Inserir no novo parent ou root
    if (newParentId === null) {
      child.parentId = null;
      items.push(child);
    } else {
      const newParent = itemMap[newParentId];
      if (!newParent) return; // Se for inv√°lido, n√£o faz nada
      
      child.parentId = newParentId;
      if (!newParent.children) {
        newParent.children = [];
      }
      newParent.children.push(child);
    }
    
    // Update modification time
    child.modified = Date.now();
    
    // Seleciona o item
    updateSelection(childId);
    saveToLocalStorage();
    renderAll();
  }

  function isAncestorOrSelf(targetId, maybeChildId) {
    if (targetId === maybeChildId) return true;
    let c = itemMap[maybeChildId];
    while (c && c.parentId) {
      if (c.parentId === targetId) return true;
      c = itemMap[c.parentId];
    }
    return false;
  }

  /*********************************************************************
   *                      NAVEGA√á√ÉO
   *********************************************************************/
  function buildVisibleList() {
    const out = [];
    function dfs(arr) {
      for (const t of arr) {
        out.push(t);
        if (!t.collapsed && t.children?.length) {
          dfs(t.children);
        }
      }
    }
    dfs(items);
    return out;
  }

  function selectNextItem() {
    const visible = buildVisibleList();
    if (!visible.length) return;
    if (selectedItemId === null) {
      updateSelection(visible[0].id);
    } else {
      const idx = visible.findIndex(t => t.id === selectedItemId);
      if (idx < 0) {
        updateSelection(visible[0].id);
      } else if (idx < visible.length - 1) {
        updateSelection(visible[idx + 1].id);
      }
    }
    renderAll();
  }

  function selectPrevItem() {
    const visible = buildVisibleList();
    if (!visible.length) return;
    if (selectedItemId === null) {
      updateSelection(visible[visible.length - 1].id);
    } else {
      const idx = visible.findIndex(t => t.id === selectedItemId);
      if (idx < 0) {
        updateSelection(visible[0].id);
      } else if (idx > 0) {
        updateSelection(visible[idx - 1].id);
      }
    }
    renderAll();
  }

  function selectFirstChild(itemId) {
    if (itemId === null) return;
    const t = itemMap[itemId];
    if (!t || !t.children?.length) return;
    
    // If collapsed, expand first
    if (t.collapsed) {
      delete t.collapsed;
      saveToLocalStorage();
    }
    
    // Always select first child if available
    updateSelection(t.children[0].id);
    renderAll();
  }

  function selectParentOrCollapse(itemId) {
    if (itemId === null) return;
    const t = itemMap[itemId];
    if (!t) return;
    
    // If current item is collapsed, move to parent
    if (t.collapsed || !t.children?.length) {
      if (t.parentId) {
        updateSelection(t.parentId);
        renderAll();
      }
      return;
    }
    
    // If expanded, collapse it
    t.collapsed = true;
    saveToLocalStorage();
    renderAll();
  }

  // Add function to move item directly under its grandparent
  function moveToGrandparent(itemId) {
    const item = itemMap[itemId];
    if (!item || !item.parentId) return;
    
    const parent = itemMap[item.parentId];
    if (!parent || !parent.parentId) return;
    
    const grandparentId = parent.parentId;
    reparentItem(itemId, grandparentId);
  }

  /*********************************************************************
   *                       RENDERIZA√á√ÉO
   *********************************************************************/
  const rootInputContainerEl = document.getElementById("rootInputContainer");
  const treeRootEl = document.getElementById("treeRoot");

  function renderItem(item, containerEl) {
    const li = document.createElement("li");
    const row = document.createElement("div");
    row.className = "item-container";
    
    // Adicionar handle para drag & drop
    const dragHandle = document.createElement("span");
    dragHandle.className = "drag-handle";
    dragHandle.textContent = "‚ãÆ‚ãÆ"; // √çcone de "arraste aqui"
    dragHandle.draggable = true;
    
    // Mover os eventos de drag para o handle
    dragHandle.addEventListener("dragstart", e => handleDragStart(e, item.id));
    dragHandle.addEventListener("dragend", e => handleDragEnd(e));
    
    // Remover draggable do row
    row.draggable = false;

    // Move these event listeners to the li element instead of the row
    li.addEventListener("dragenter", e => {
      e.preventDefault();
      if (draggingItemId && draggingItemId !== item.id && !isAncestorOrSelf(item.id, draggingItemId)) {
        row.classList.add("drag-hover");
      }
    });

    li.addEventListener("dragover", e => {
      e.preventDefault();
      if (draggingItemId && draggingItemId !== item.id && !isAncestorOrSelf(item.id, draggingItemId)) {
        row.classList.add("drag-hover");
      }
    });

    li.addEventListener("dragleave", e => {
      if (!li.contains(e.relatedTarget)) {
        row.classList.remove("drag-hover");
      }
    });

    li.addEventListener("drop", e => {
      e.preventDefault();
      e.stopPropagation();
      row.classList.remove("drag-hover");
      if (draggingItemId && draggingItemId !== item.id && !isAncestorOrSelf(item.id, draggingItemId)) {
        reparentItem(draggingItemId, item.id);
      }
    });

    // Sele√ß√£o & ancestrais
    if (selectedItemId === item.id) {
      row.classList.add("selected");
    }
    const ancestors = getAncestorIds(selectedItemId);
    if (ancestors.includes(item.id)) {
      row.classList.add("ancestor-of-selected");
    }

    // Toggle ou placeholder
    if (item.children?.length) {
      const toggle = document.createElement("span");
      toggle.className = "toggle-btn";
      toggle.textContent = item.collapsed ? "[+]" : "[-]";
      toggle.onclick = e => {
        e.stopPropagation();
        toggleItemExpand(item.id);
        renderAll();
      };
      row.appendChild(toggle);
    } else {
      const placeholder = document.createElement("span");
      placeholder.className = "toggle-placeholder";
      row.appendChild(placeholder);
    }

    // Adicionar o handle antes do texto
    row.appendChild(dragHandle);
    
    // Label (agora selecion√°vel)
    const labelSpan = document.createElement("span");
    labelSpan.className = "item-label";
    labelSpan.textContent = item.value;
    row.appendChild(labelSpan);
    
    // Add double-click handler to the row
    row.addEventListener('dblclick', e => {
      e.stopPropagation();
      e.preventDefault();
      const projectId = HashProtocol.parse(window.location.hash)?.projectId || 'default';
      window.location.hash = HashProtocol.create(projectId, item.id);
    });
    
    // Make sure single click doesn't interfere with double click
    labelSpan.onclick = e => {
      e.stopPropagation();
      updateSelection(item.id);
      updateDraftValue("");
      renderAll();
    };

    // Se for o item selecionado, exibir input
    if (selectedItemId === item.id) {
      const inputEl = document.createElement("input");
      inputEl.id = "singleInput";
      inputEl.value = draftValue;
      inputEl.onkeydown = handleSingleInputKeyDown;
      inputEl.oninput = handleInputChange;
      inputEl.onclick = e => e.stopPropagation();
      setTimeout(() => inputEl.focus(), 0);
      row.appendChild(inputEl);
    }

    const effectiveStatus = getEffectiveStatus(item.id);
    row.setAttribute('data-status', effectiveStatus);
    
    // Only allow status cycling for leaf nodes
    if (!item.children?.length && item.type === 'actionable') {
      row.addEventListener('click', e => {
        if (e.offsetX < 30) {
          e.stopPropagation();
          cycleItemStatus(item.id);
          renderAll();
        }
      });
    }

    li.appendChild(row);

    // Renderizar filhos se expandido
    if (!item.collapsed && item.children?.length) {
      const childUl = document.createElement("ul");
      item.children.forEach(c => renderItem(c, childUl));
      li.appendChild(childUl);
    }

    containerEl.appendChild(li);
  }

  function renderAll() {
    rootInputContainerEl.innerHTML = "";
    treeRootEl.innerHTML = "";

    if (!items.length || selectedItemId === null) {
      renderRootInput();
    }

    items.forEach(t => {
      renderItem(t, treeRootEl);
    });
  }

  function renderRootInput() {
    const inputEl = document.createElement("input");
    inputEl.id = "singleInput";
    inputEl.value = draftValue;
    inputEl.placeholder = "Digite para adicionar ao root...";
    inputEl.onkeydown = handleSingleInputKeyDown;
    inputEl.oninput = handleInputChange;
    setTimeout(() => inputEl.focus(), 0);
    rootInputContainerEl.appendChild(inputEl);

    // Permitir drop no root
    rootInputContainerEl.addEventListener("dragover", e => e.preventDefault());
    rootInputContainerEl.addEventListener("dragenter", e => {
      e.preventDefault();
      rootInputContainerEl.classList.add("root-drop-target");
    });
    rootInputContainerEl.addEventListener("dragleave", e => {
      rootInputContainerEl.classList.remove("root-drop-target");
    });
    rootInputContainerEl.addEventListener("drop", e => {
      e.preventDefault();
      rootInputContainerEl.classList.remove("root-drop-target");
      if (draggingItemId) {
        reparentItem(draggingItemId, null);
      }
    });
  }

  function handleSingleInputKeyDown(e) {
    // If there's text in the input, only allow text navigation
    if (draftValue.trim()) {
        if (e.key === "Enter" || e.key === "Tab") {
            e.preventDefault();
            if (!draftValue) return;

            let newItem;
            if (e.key === "Enter") {
                // Enter creates child
                if (selectedItemId === null) {
                    newItem = addTopLevelItem(draftValue);
                } else {
                    newItem = addChildItem(selectedItemId, draftValue);
                }
            } else { // Tab creates sibling
                if (selectedItemId === null) {
                    newItem = addTopLevelItem(draftValue);
                } else {
                    newItem = addSiblingItem(selectedItemId, draftValue);
                }
            }

            if (newItem) {
                updateSelection(newItem.id);
            }
            updateDraftValue("");
            renderAll();
        }
        return; // Block other navigation when editing
    }

    // Navigation keys
    if (e.key === "ArrowDown") {
      e.preventDefault();
      selectNextItem();
    }
    else if (e.key === "ArrowUp") {
      e.preventDefault();
      selectPrevItem();
    }
    else if (e.key === "ArrowRight") {
      e.preventDefault();
      selectFirstChild(selectedItemId);
    }
    else if (e.key === "ArrowLeft") {
      e.preventDefault();
      selectParentOrCollapse(selectedItemId);
    }
    else if (e.key === "Backspace" && e.altKey) {
      e.preventDefault();
      moveToGrandparent(selectedItemId);
    }
  }

  function handleInputChange(e) {
    updateDraftValue(e.target.value);
  }

  /*********************************************************************
   *         TECLA DELETE => DELETAR ITEM SELECIONADO
   *********************************************************************/
  document.addEventListener("keydown", e => {
    if (e.key === "Delete") {
        if (selectedItemId !== null && !draftValue.trim()) {
            deleteItem(selectedItemId);
            // selectedItemId = null;
            // draftValue = "";
            // renderAll();
        }
    }
  });

  /*********************************************************************
   *         CLIQUE FORA => DESELECIONAR
   *********************************************************************/
  document.addEventListener("click", e => {
    const isInsideTree = treeRootEl.contains(e.target);
    const isInsideRoot = rootInputContainerEl.contains(e.target);
    if (!isInsideTree && !isInsideRoot) {
      updateSelection(null);
      updateDraftValue("");
      renderAll();
    }
  });

  /*********************************************************************
   *        DROP NO BODY => RE-PARENT PARA ROOT
   *********************************************************************/
  document.addEventListener("dragover", e => e.preventDefault());
  document.addEventListener("drop", e => {
    e.preventDefault();
    // Se n√£o foi tratado por um filho, cair√° aqui
    if (draggingItemId) {
      reparentItem(draggingItemId, null);
    }
  });

  /*********************************************************************
   *            EXPORTAR COMO JSON
   *********************************************************************/
  const exportBtn = document.getElementById("exportBtn");
  exportBtn.onclick = () => {
    const json = JSON.stringify(items, null, 2);
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(json);
    const dlAnchor = document.createElement("a");
    dlAnchor.setAttribute("href", dataStr);
    dlAnchor.setAttribute("download", "items.json");
    dlAnchor.click();
  };

  /*********************************************************************
   *                      HASH PROTOCOL HANDLER
   *********************************************************************/
  class HashProtocol {
    static SEPARATOR = ':';
    
    // Parse hash into structured data
    static parse(hash) {
      if (!hash) {
        // Empty hash means 'default' project
        return {
          projectId: 'default',
          resourceId: null
        };
      }
      
      // Remove leading #
      hash = hash.startsWith('#') ? hash.slice(1) : hash;
      
      // Split by separator
      const [projectId, resourceId] = hash.split(HashProtocol.SEPARATOR);
      
      return {
        projectId: projectId || 'default', // Empty projectId also means 'default'
        resourceId // null if not present
      };
    }
    
    // Create hash string from parts
    static create(projectId, resourceId = null) {
      // Don't create hash for default project without resource
      if (projectId === 'default' && !resourceId) {
        return '';
      }
      
      let hash = projectId;
      if (resourceId) {
        hash += HashProtocol.SEPARATOR + resourceId;
      }
      
      return hash;
    }
  }

  // Store the hash handler when initializing
  let hashHandler;

  /*********************************************************************
   *            INICIALIZA√á√ÉO
   *********************************************************************/
  async function init() {
    // Load initial data from localStorage
    loadFromLocalStorage();
    loadMetaState();
    renderAll();
    // Initialize hash handling after initial data is loaded
    hashHandler = initHashPlaceHandling();
  }

  // Call init and handle any errors
  init().catch(error => {
    console.error('Initialization error:', error);
  });

  // Add this to help debug
  window.addEventListener('load', () => {
    console.log('After load - selectedItemId:', selectedItemId);
    console.log('localStorage selection:', localStorage.getItem(LS_SELECTION_KEY));
  });

  // Add this function to clean up the data structure
  function cleanupDataStructure(items) {
    const now = Date.now();
    
    function cleanItem(item) {
      // Create new object with only necessary properties
      const cleaned = {
        id: item.id,
        value: item.value,
        modified: item.modified || now  // Ensure modified always exists
      };
      
      // Only add parentId if not at root
      if (item.parentId) {
        cleaned.parentId = item.parentId;
      }
      
      // Only add children if they exist and not empty
      if (item.children?.length > 0) {
        cleaned.children = item.children.map(cleanItem);
        // Preserve collapsed state
        if (item.collapsed) {
          cleaned.collapsed = true;
        }
      }
      
      // Only add status if not 'seed'
      if (item.status && item.status !== 'seed') {
        cleaned.status = item.status;
      }
      
      return cleaned;
    }
    
    return items.map(cleanItem);
  }

  // Update drag handlers to use meta state
  function handleDragStart(e, itemId) {
    metaState.draggingItemId = itemId;
    draggingItemId = itemId;
    saveMetaState();
  }

  function handleDragEnd(e) {
    metaState.draggingItemId = null;
    draggingItemId = null;
    saveMetaState();
    // Clear any stuck hover states
    document.querySelectorAll('.drag-hover').forEach(el => el.classList.remove('drag-hover'));
  }

  // Update selection handlers
  function updateSelection(itemId) {
    selectedItemId = itemId;
    metaState.selectedItemId = itemId;
    saveMetaState();
  }

  // Update draft text handler
  function updateDraftValue(value) {
    draftValue = value;
    metaState.draftValue = value;
    saveMetaState();
  }

  // Update status handling to reflect child states
  function getEffectiveStatus(itemId) {
    const item = itemMap[itemId];
    if (!item) return 'seed';
    
    // If it has no children, use its own status
    if (!item.children?.length) {
      return item.status || 'seed';
    }
    
    // Get all child statuses
    const childStatuses = item.children.map(child => getEffectiveStatus(child.id));
    
    // Priority order (most critical first)
    const priorityOrder = ['needs-water', 'under-sun', 'blooming', 'harvest', 'dormant', 'pruned', 'seed'];
    
    // Return the highest priority status found in children
    for (const status of priorityOrder) {
      if (childStatuses.includes(status)) {
        return status;
      }
    }
    
    return 'seed';
  }

  /*********************************************************************
   *                      HASH PROTOCOL HANDLER
   *********************************************************************/
  function initHashPlaceHandling() {
    let lastProjectId = null;
    let lastResourceId = null;
    let isProcessingHashChange = false;

    async function loadFromHash() {
        if (isProcessingHashChange) return;
        isProcessingHashChange = true;

        const hash = window.location.hash.slice(1);
        const context = HashProtocol.parse(hash);
        
        const projectId = context?.projectId || 'default';
        
        // Only reload project data if project ID changes
        if (projectId !== lastProjectId) {
            const projectData = await DataSource.load(projectId);
            if (projectData) {
                items = projectData;
                rebuildItemMap(items);
                currentProjectId = projectId;
                lastProjectId = projectId;
                renderAll();
            }
        }
        
        // Reset lastResourceId when there's no resource in context
        if (!context?.resourceId) {
            lastResourceId = null;
        }
        
        // Handle dialog visibility
        if (context?.resourceId !== lastResourceId) {
            if (context?.resourceId && itemMap[context.resourceId]) {
                renderContextDialog(context.resourceId);
            } else if (lastResourceId) {
                closeDialog(false);
            }
            lastResourceId = context?.resourceId;
        }

        isProcessingHashChange = false;
    }

    window.addEventListener('hashchange', loadFromHash, false);
    loadFromHash();
    
    return { loadFromHash, closeDialog };
  }

  function closeDialog(updateHash = true) {
    const backdrop = document.querySelector('.dialog-backdrop');
    if (backdrop) {
        backdrop.style.opacity = '0';
        setTimeout(() => {
            backdrop.remove();
            if (updateHash) {
                const projectId = HashProtocol.parse(window.location.hash)?.projectId || 'default';
                const newHash = HashProtocol.create(projectId);
                // Use replaceState and trigger hashchange manually
                history.replaceState(null, '', newHash ? '#' + newHash : '#');
                window.dispatchEvent(new HashChangeEvent('hashchange'));
            }
        }, 150);
    }
  }

  function renderContextDialog(itemId) {
    const item = itemMap[itemId];
    if (!item) return;

    // Remove existing dialog if any
    const existingDialog = document.querySelector('.dialog-backdrop');
    if (existingDialog) {
      existingDialog.remove();
    }

    // Create backdrop
    const backdrop = document.createElement('div');
    backdrop.className = 'dialog-backdrop';
    
    // Update backdrop click handler to use HashProtocol
    backdrop.onclick = (e) => {
      if (e.target === backdrop) {
        closeDialog();
      }
    };

    // Create dialog
    const dialog = document.createElement('div');
    dialog.className = 'context-dialog';
    dialog.onclick = (e) => e.stopPropagation(); // Prevent clicks from bubbling to backdrop

    // Header with close button
    const header = document.createElement('div');
    header.className = 'dialog-header';
    
    const title = document.createElement('h2');
    title.textContent = item.value;
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'close-button';
    closeBtn.innerHTML = '√ó';
    closeBtn.onclick = closeDialog;

    header.appendChild(title);
    header.appendChild(closeBtn);

    // Content
    const content = document.createElement('div');
    content.className = 'dialog-content';
    
    // Add item details
    const details = document.createElement('div');
    details.innerHTML = `
      <p><strong>ID:</strong> ${item.id}</p>
      <p><strong>Status:</strong> ${item.status || 'seed'}</p>
      <p><strong>Modified:</strong> ${new Date(item.modified).toLocaleString()}</p>
      ${item.parentId ? `<p><strong>Parent:</strong> ${itemMap[item.parentId]?.value || 'Unknown'}</p>` : ''}
      ${item.children?.length ? `<p><strong>Children:</strong> ${item.children.length}</p>` : ''}
    `;
    
    content.appendChild(details);

    // Assemble dialog
    dialog.appendChild(header);
    dialog.appendChild(content);
    backdrop.appendChild(dialog);
    
    // Add to document
    document.body.appendChild(backdrop);
  }
</script>

</body>
</html>

