<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Project Arbor - LocalStorage, Global Drag ID</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      user-select: none; 
    }

    h1 {
      margin-bottom: 0.5em;
    }

    /* Regi√£o para adicionar tarefas no root (quando n√£o h√° item selecionado ou lista vazia) */
    .root-input-area {
      position: absolute;
      height: 2em;
      z-index: 1;
    }

    ul {
      list-style: none;
      margin-left: 0;
      padding-left: 20px; /* indent b√°sico */
    }

    li {
      margin: 0.25em 0;
    }

    /* Reset positioning */
    .task-container {
      position: relative;
      padding-left: 24px; /* Space for status emoji */
      line-height: 24px;
    }

    /* Status emoji */
    .task-container::before {
      content: "üå±";
      position: absolute;
      left: 2px;
      cursor: pointer;
    }

    /* Expand button */
    .expand-button {
      position: absolute;
      left: -20px; /* Adjust if needed to align properly */
      top: 50%;
      cursor: pointer;
    }

    /* Task row should be relative to allow proper stacking */
    .task-row {
      position: relative;
      width: 100%;
    }

    /* Hover b√°sico */
    .task-container:hover {
      background-color: #f8f8f8;
    }

    /* Selec√ß√£o do item */
    .task-container.selected {
      outline: 2px solid #007BFF;
      border-radius: 3px;
    }

    /* Destaque para ancestrais do selecionado */
    .task-container.ancestor-of-selected {
      background-color: #e3f2e3;
      border-radius: 3px;
      margin-left: -5px;
    }

    /* Destaque quando √© um alvo de drop v√°lido */
    .task-container.drag-hover {
      border: 2px dashed #007BFF;
      background-color: #ccf2ff;
    }

    /* Bot√£o de expandir/recolher com posicionamento absoluto do seu jeito */
    .toggle-btn {
      position: absolute;
      margin-left: -37px;
      font-size: 0.9em;
      cursor: pointer;
    }
    .toggle-placeholder {
      position: absolute;
      margin-left: -5%;
      width: 30px;
    }

    /* Input √∫nico de texto */
    #singleInput {
      border: 1px solid #888;
      border-radius: 3px;
      padding: 2px 4px;
      font-size: 0.9em;
      width: 150px;
      margin-left: 8px;
      box-sizing: border-box; /* Include padding and border in element's total width */
    }

    #exportBtn {
      margin-bottom: 1em;
      position: relative;
      z-index: 2;
    }

    /* Destaque quando solta no root */
    .root-drop-target {
      outline: 2px dashed #007BFF;
      min-height: 20px;
      margin: 10px 0;
      background-color: #eef9ff;
      transition: background-color 0.2s;
    }

    .task-container::before:hover {
      background-color: #f0f0f0;
    }

    .task-container[data-status="blooming"]::before {
      content: "üå∏";
    }

    .task-container[data-status="needs-water"]::before {
      content: "üíß";
    }

    .task-container[data-status="under-sun"]::before {
      content: "‚òÄÔ∏è";
    }

    .task-container[data-status="harvest"]::before {
      content: "üåæ";
    }

    .task-container[data-status="dormant"]::before {
      content: "üí§";
    }

    .task-container[data-status="pruned"]::before {
      content: "‚úÇÔ∏è";
    }

    #treeRoot {
      position: relative;
      z-index: 1;
      margin-top: 3em; /* Add margin to create space for the root input */
    }

    /* When there's no selection or items, remove the margin */
    #treeRoot:empty {
      margin-top: 0;
    }

    /* Add these new styles */
    .context-dialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      min-width: 300px;
      max-width: 80vw;
      max-height: 80vh;
      overflow-y: auto;
    }

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 999;
    }

    .dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      padding: 0.2em 0.5em;
    }

    .close-button:hover {
      background: #f0f0f0;
      border-radius: 4px;
    }
  </style>
</head>
<body>

<h1>Project Arbor</h1>

<button id="exportBtn">Export as JSON</button>
<div id="rootInputContainer" class="root-input-area"></div>
<ul id="treeRoot"></ul>

<script>
  /*********************************************************************
   *                         ESTADO & VARI√ÅVEIS
   *********************************************************************/
  // Add data source abstraction first
  const DataSource = {
    async save(key, data) {
      // For now, use localStorage
      localStorage.setItem(key, JSON.stringify(data));
    },
    
    async load(key) {
      // For now, use localStorage
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    }
  };

  let tasks = [];          // Lista de tarefas no root
  let taskMap = {};        // Mapa de ID -> objeto da tarefa
  let selectedTaskId = null;
  let draftText = "";
  
  const LS_KEY = "arbor_tasks";
  
  // Ao inv√©s de usar dataTransfer para armazenar o ID,
  // usaremos essa vari√°vel global para contornar problemas de browsers.
  let draggingItemId = null; 

  const STATUSES = ['seed', 'blooming', 'needs-water', 'under-sun', 'harvest', 'dormant', 'pruned'];

  // Add a new constant for the selection storage key
  const LS_SELECTION_KEY = "arbor_selection";

  // Add constants for meta storage
  const LS_META_KEY = "arbor_meta";

  // Global meta state
  let metaState = {
    selectedTaskId: null,
    draggingItemId: null,
    draftText: ""
  };

  // Add currentProjectId to state
  let currentProjectId = 'default';

  /**
   * Returns an array of all ancestor IDs (parent, grandparent, etc.)
   * for a given task ID, in order from immediate parent up.
   */
  function getAncestorIds(taskId) {
    const result = [];
    let current = taskMap[taskId];
    while (current && current.parentId) {
      result.push(current.parentId);
      current = taskMap[current.parentId];
    }
    return result;
  }

  /*********************************************************************
   *                      FUN√á√ïES DE LOCALSTORAGE
   *********************************************************************/
  function saveToLocalStorage() {
    const json = JSON.stringify(tasks);
    localStorage.setItem(LS_KEY, json);
  }

  function loadFromLocalStorage() {
    const stored = localStorage.getItem(LS_KEY);
    if (!stored) {
      tasks = [];
      taskMap = {};
      return;
    }
    try {
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed)) {
        tasks = cleanupDataStructure(parsed);
      } else {
        tasks = [];
      }
    } catch {
      tasks = [];
    }
    taskMap = {};
    rebuildTaskMap(tasks);
  }

  function rebuildTaskMap(list) {
    for (const t of list) {
      taskMap[t.id] = t;
      if (Array.isArray(t.children) && t.children.length > 0) {
        rebuildTaskMap(t.children);
      }
    }
  }

  function saveMetaState() {
    localStorage.setItem(LS_META_KEY, JSON.stringify(metaState));
  }

  function loadMetaState() {
    const stored = localStorage.getItem(LS_META_KEY);
    if (!stored) return;
    
    try {
      const parsed = JSON.parse(stored);
      metaState = {
        ...metaState,  // Keep defaults
        ...parsed      // Override with stored values
      };
      
      // Restore global variables from meta state
      selectedTaskId = metaState.selectedTaskId;
      draggingItemId = metaState.draggingItemId;
      draftText = metaState.draftText;
      
      // Validate that selected task still exists
      if (selectedTaskId && !taskMap[selectedTaskId]) {
        selectedTaskId = null;
        metaState.selectedTaskId = null;
        saveMetaState();
      }
    } catch (e) {
      console.error('Error loading meta state:', e);
    }
  }

  /*********************************************************************
   *                      CRIA√á√ÉO & MODIFICA√á√ÉO
   *********************************************************************/
  function createTask(text, parentId = null, type = 'actionable') {
    const task = {
      id: crypto.randomUUID(),
      text,
      modified: Date.now(),
      type,
      tldr: '',        // Brief description
      details: '',     // Detailed information
      parentId
    };
    
    if (parentId) {
      task.parentId = parentId;
    }
    
    taskMap[task.id] = task;
    return task;
  }

  function addTopLevelTask(text) {
    const t = createTask(text, null);
    tasks.push(t);
    saveToLocalStorage();
    return t;
  }

  function addChildTask(parentId, text) {
    const parent = taskMap[parentId];
    if (!parent) return null;
    
    const child = createTask(text, parentId);
    
    // Create children array only when needed
    if (!parent.children) {
      parent.children = [];
    }
    parent.children.push(child);
    
    // Remove collapsed state if it exists
    delete parent.collapsed;
    
    saveToLocalStorage();
    return child;
  }

  function addSiblingTask(taskId, text) {
    const task = taskMap[taskId];
    if (!task) return null;
    const parentId = task.parentId;
    const newTask = createTask(text, parentId);

    if (parentId === null) {
      // Irm√£o top-level
      const idx = tasks.indexOf(task);
      if (idx < 0) {
        tasks.push(newTask);
      } else {
        tasks.splice(idx + 1, 0, newTask);
      }
    } else {
      const parent = taskMap[parentId];
      if (!parent) return null;
      const idx = parent.children.indexOf(task);
      if (idx < 0) {
        parent.children.push(newTask);
      } else {
        parent.children.splice(idx + 1, 0, newTask);
      }
    }
    saveToLocalStorage();
    return newTask;
  }

  function deleteTask(taskId) {
    const task = taskMap[taskId];
    if (!task) return;

    const nextSelectedId = findNextTaskToSelect(taskId);
    
    // Remove from parent or root
    if (task.parentId === null) {
      tasks = tasks.filter(t => t.id !== taskId);
    } else {
      const p = taskMap[task.parentId];
      if (p) {
        p.children = p.children.filter(c => c.id !== taskId);
        // If last child was removed, delete the children array
        if (p.children.length === 0) {
          delete p.children;
        }
      }
    }
    
    removeFromMap(task);
    updateSelection(nextSelectedId);
    updateDraftText("");
    saveToLocalStorage();
  }

  function findNextTaskToSelect(taskId) {
    const task = taskMap[taskId];
    if (!task) return null;
    
    const visible = buildVisibleList();
    const currentIndex = visible.findIndex(t => t.id === taskId);
    
    if (currentIndex === -1) return null;
    
    // If this is the only child, select the parent
    if (task.parentId && taskMap[task.parentId]?.children?.length === 1) {
      return task.parentId;
    }
    
    // Try to select previous sibling
    if (currentIndex > 0) {
      return visible[currentIndex - 1].id;
    }
    
    // If no previous sibling, try next sibling
    if (currentIndex < visible.length - 1) {
      return visible[currentIndex + 1].id;
    }
    
    // If no siblings, select parent
    if (task.parentId) {
      return task.parentId;
    }
    
    // If no parent (root level), return null
    return null;
  }

  function removeFromMap(task) {
    for (const child of task.children) {
      removeFromMap(child);
    }
    delete taskMap[task.id];
  }

  function toggleTaskExpand(taskId) {
    const t = taskMap[taskId];
    if (!t || !t.children?.length) return;
    
    if (t.collapsed) {
      delete t.collapsed;
    } else {
      t.collapsed = true;
    }
    
    updateSelection(taskId);
    t.modified = Date.now(); // Update modification time when collapsing/expanding
    saveToLocalStorage();
  }

  function cycleTaskStatus(taskId) {
    const task = taskMap[taskId];
    if (!task) return;
    
    const currentIdx = STATUSES.indexOf(task.status || 'seed');
    const newStatus = STATUSES[(currentIdx + 1) % STATUSES.length];
    
    // Only store non-default status
    if (newStatus === 'seed') {
      delete task.status;
    } else {
      task.status = newStatus;
    }
    
    task.modified = Date.now();
    saveToLocalStorage();
  }

  /*********************************************************************
   *                    DRAG & DROP (VAR GLOBAL)
   *********************************************************************/
  function reparentTask(childId, newParentId) {
    if (!taskMap[childId]) return;
    // Evitar loops
    if (newParentId !== null && isAncestorOrSelf(newParentId, childId)) return;

    // Remover do antigo parent ou root
    const child = taskMap[childId];
    if (child.parentId === null) {
      tasks = tasks.filter(t => t.id !== childId);
    } else {
      const oldParent = taskMap[child.parentId];
      if (oldParent) {
        oldParent.children = oldParent.children.filter(c => c.id !== childId);
        // If last child was removed, delete the children array
        if (oldParent.children.length === 0) {
          delete oldParent.children;
        }
      }
    }

    // Inserir no novo parent ou root
    if (newParentId === null) {
      child.parentId = null;
      tasks.push(child);
    } else {
      const newParent = taskMap[newParentId];
      if (!newParent) return; // Se for inv√°lido, n√£o faz nada
      
      child.parentId = newParentId;
      if (!newParent.children) {
        newParent.children = [];
      }
      newParent.children.push(child);
    }
    
    // Update modification time
    child.modified = Date.now();
    
    // Seleciona o item
    updateSelection(childId);
    saveToLocalStorage();
    renderAll();
  }

  function isAncestorOrSelf(targetId, maybeChildId) {
    if (targetId === maybeChildId) return true;
    let c = taskMap[maybeChildId];
    while (c && c.parentId) {
      if (c.parentId === targetId) return true;
      c = taskMap[c.parentId];
    }
    return false;
  }

  /*********************************************************************
   *                      NAVEGA√á√ÉO
   *********************************************************************/
  function buildVisibleList() {
    const out = [];
    function dfs(arr) {
      for (const t of arr) {
        out.push(t);
        if (!t.collapsed && t.children?.length) {
          dfs(t.children);
        }
      }
    }
    dfs(tasks);
    return out;
  }

  function selectNextTask() {
    const visible = buildVisibleList();
    if (!visible.length) return;
    if (selectedTaskId === null) {
      updateSelection(visible[0].id);
    } else {
      const idx = visible.findIndex(t => t.id === selectedTaskId);
      if (idx < 0) {
        updateSelection(visible[0].id);
      } else if (idx < visible.length - 1) {
        updateSelection(visible[idx + 1].id);
      }
    }
    renderAll();
  }

  function selectPrevTask() {
    const visible = buildVisibleList();
    if (!visible.length) return;
    if (selectedTaskId === null) {
      updateSelection(visible[visible.length - 1].id);
    } else {
      const idx = visible.findIndex(t => t.id === selectedTaskId);
      if (idx < 0) {
        updateSelection(visible[0].id);
      } else if (idx > 0) {
        updateSelection(visible[idx - 1].id);
      }
    }
    renderAll();
  }

  function selectFirstChild(taskId) {
    if (taskId === null) return;
    const t = taskMap[taskId];
    if (!t || !t.children?.length) return;
    
    // If collapsed, expand first
    if (t.collapsed) {
      delete t.collapsed;
      saveToLocalStorage();
    }
    
    // Always select first child if available
    updateSelection(t.children[0].id);
    renderAll();
  }

  function selectParentOrCollapse(taskId) {
    if (taskId === null) return;
    const t = taskMap[taskId];
    if (!t) return;
    
    // If current item is collapsed, move to parent
    if (t.collapsed || !t.children?.length) {
      if (t.parentId) {
        updateSelection(t.parentId);
        renderAll();
      }
      return;
    }
    
    // If expanded, collapse it
    t.collapsed = true;
    saveToLocalStorage();
    renderAll();
  }

  // Add function to move task directly under its grandparent
  function moveToGrandparent(taskId) {
    const task = taskMap[taskId];
    if (!task || !task.parentId) return;
    
    const parent = taskMap[task.parentId];
    if (!parent || !parent.parentId) return;
    
    const grandparentId = parent.parentId;
    reparentTask(taskId, grandparentId);
  }

  /*********************************************************************
   *                       RENDERIZA√á√ÉO
   *********************************************************************/
  const rootInputContainerEl = document.getElementById("rootInputContainer");
  const treeRootEl = document.getElementById("treeRoot");

  function renderTask(task, containerEl) {
    const li = document.createElement("li");
    const row = document.createElement("div");
    row.className = "task-container";
    
    // DRAG & DROP 
    row.draggable = true;
    row.addEventListener("dragstart", e => handleDragStart(e, task.id));
    row.addEventListener("dragend", e => handleDragEnd(e));

    // Move these event listeners to the li element instead of the row
    li.addEventListener("dragenter", e => {
      e.preventDefault();
      if (draggingItemId && draggingItemId !== task.id && !isAncestorOrSelf(task.id, draggingItemId)) {
        row.classList.add("drag-hover");
      }
    });

    li.addEventListener("dragover", e => {
      e.preventDefault();
      if (draggingItemId && draggingItemId !== task.id && !isAncestorOrSelf(task.id, draggingItemId)) {
        row.classList.add("drag-hover");
      }
    });

    li.addEventListener("dragleave", e => {
      if (!li.contains(e.relatedTarget)) {
        row.classList.remove("drag-hover");
      }
    });

    li.addEventListener("drop", e => {
      e.preventDefault();
      e.stopPropagation();
      row.classList.remove("drag-hover");
      if (draggingItemId && draggingItemId !== task.id && !isAncestorOrSelf(task.id, draggingItemId)) {
        reparentTask(draggingItemId, task.id);
      }
    });

    // Sele√ß√£o & ancestrais
    if (selectedTaskId === task.id) {
      row.classList.add("selected");
    }
    const ancestors = getAncestorIds(selectedTaskId);
    if (ancestors.includes(task.id)) {
      row.classList.add("ancestor-of-selected");
    }

    // Toggle ou placeholder
    if (task.children?.length) {
      const toggle = document.createElement("span");
      toggle.className = "toggle-btn";
      toggle.textContent = task.collapsed ? "[+]" : "[-]";
      toggle.onclick = e => {
        e.stopPropagation();
        toggleTaskExpand(task.id);
        renderAll();
      };
      row.appendChild(toggle);
    } else {
      const placeholder = document.createElement("span");
      placeholder.className = "toggle-placeholder";
      row.appendChild(placeholder);
    }

    // Label
    const labelSpan = document.createElement("span");
    labelSpan.textContent = task.text;
    row.appendChild(labelSpan);
    
    // Add double-click handler to the row
    row.addEventListener('dblclick', e => {
      e.stopPropagation();
      e.preventDefault();
      const projectId = HashProtocol.parse(window.location.hash)?.projectId || 'default';
      window.location.hash = HashProtocol.create(projectId, task.id);
    });
    
    // Make sure single click doesn't interfere with double click
    labelSpan.onclick = e => {
      e.stopPropagation();
      updateSelection(task.id);
      updateDraftText("");
      renderAll();
    };

    // Se for o item selecionado, exibir input
    if (selectedTaskId === task.id) {
      const inputEl = document.createElement("input");
      inputEl.id = "singleInput";
      inputEl.value = draftText;
      inputEl.onkeydown = handleSingleInputKeyDown;
      inputEl.oninput = handleInputChange;
      inputEl.onclick = e => e.stopPropagation();
      setTimeout(() => inputEl.focus(), 0);
      row.appendChild(inputEl);
    }

    const effectiveStatus = getEffectiveStatus(task.id);
    row.setAttribute('data-status', effectiveStatus);
    
    // Only allow status cycling for leaf nodes
    if (!task.children?.length && task.type === 'actionable') {
      row.addEventListener('click', e => {
        if (e.offsetX < 30) {
          e.stopPropagation();
          cycleTaskStatus(task.id);
          renderAll();
        }
      });
    }

    li.appendChild(row);

    // Renderizar filhos se expandido
    if (!task.collapsed && task.children?.length) {
      const childUl = document.createElement("ul");
      task.children.forEach(c => renderTask(c, childUl));
      li.appendChild(childUl);
    }

    containerEl.appendChild(li);
  }

  function renderAll() {
    rootInputContainerEl.innerHTML = "";
    treeRootEl.innerHTML = "";

    if (!tasks.length || selectedTaskId === null) {
      renderRootInput();
    }

    tasks.forEach(t => {
      renderTask(t, treeRootEl);
    });
  }

  function renderRootInput() {
    const inputEl = document.createElement("input");
    inputEl.id = "singleInput";
    inputEl.value = draftText;
    inputEl.placeholder = "Digite para adicionar ao root...";
    inputEl.onkeydown = handleSingleInputKeyDown;
    inputEl.oninput = handleInputChange;
    setTimeout(() => inputEl.focus(), 0);
    rootInputContainerEl.appendChild(inputEl);

    // Permitir drop no root
    rootInputContainerEl.addEventListener("dragover", e => e.preventDefault());
    rootInputContainerEl.addEventListener("dragenter", e => {
      e.preventDefault();
      rootInputContainerEl.classList.add("root-drop-target");
    });
    rootInputContainerEl.addEventListener("dragleave", e => {
      rootInputContainerEl.classList.remove("root-drop-target");
    });
    rootInputContainerEl.addEventListener("drop", e => {
      e.preventDefault();
      rootInputContainerEl.classList.remove("root-drop-target");
      if (draggingItemId) {
        reparentTask(draggingItemId, null);
      }
    });
  }

  function handleSingleInputKeyDown(e) {
    // If there's text in the input, only allow text navigation
    if (draftText.trim()) {
      if (e.key === "Enter" || e.key === "Tab") {
        e.preventDefault();
        if (!draftText) return;
        if (selectedTaskId === null) {
          const newTask = addTopLevelTask(draftText);
          updateSelection(newTask.id);
        } else {
          const newTask = addChildTask(selectedTaskId, draftText);
          if (newTask) {
            updateSelection(newTask.id);
          }
        }
        updateDraftText("");
        renderAll();
      }
      return; // Block other navigation when editing
    }

    // Navigation keys
    if (e.key === "ArrowDown") {
      e.preventDefault();
      selectNextTask();
    }
    else if (e.key === "ArrowUp") {
      e.preventDefault();
      selectPrevTask();
    }
    else if (e.key === "ArrowRight") {
      e.preventDefault();
      selectFirstChild(selectedTaskId);
    }
    else if (e.key === "ArrowLeft") {
      e.preventDefault();
      selectParentOrCollapse(selectedTaskId);
    }
    else if (e.key === "Backspace" && e.altKey) {
      e.preventDefault();
      moveToGrandparent(selectedTaskId);
    }
  }

  function handleInputChange(e) {
    updateDraftText(e.target.value);
  }

  /*********************************************************************
   *         TECLA DELETE => DELETAR ITEM SELECIONADO
   *********************************************************************/
  document.addEventListener("keydown", e => {
    if (e.key === "Delete") {
      if (selectedTaskId !== null) {
        deleteTask(selectedTaskId);
        selectedTaskId = null;
        draftText = "";
        renderAll();
      }
    }
  });

  /*********************************************************************
   *         CLIQUE FORA => DESELECIONAR
   *********************************************************************/
  document.addEventListener("click", e => {
    const isInsideTree = treeRootEl.contains(e.target);
    const isInsideRoot = rootInputContainerEl.contains(e.target);
    if (!isInsideTree && !isInsideRoot) {
      updateSelection(null);
      updateDraftText("");
      renderAll();
    }
  });

  /*********************************************************************
   *        DROP NO BODY => RE-PARENT PARA ROOT
   *********************************************************************/
  document.addEventListener("dragover", e => e.preventDefault());
  document.addEventListener("drop", e => {
    e.preventDefault();
    // Se n√£o foi tratado por um filho, cair√° aqui
    if (draggingItemId) {
      reparentTask(draggingItemId, null);
    }
  });

  /*********************************************************************
   *            EXPORTAR COMO JSON
   *********************************************************************/
  const exportBtn = document.getElementById("exportBtn");
  exportBtn.onclick = () => {
    const json = JSON.stringify(tasks, null, 2);
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(json);
    const dlAnchor = document.createElement("a");
    dlAnchor.setAttribute("href", dataStr);
    dlAnchor.setAttribute("download", "tasks.json");
    dlAnchor.click();
  };

  /*********************************************************************
   *                      HASH PROTOCOL HANDLER
   *********************************************************************/
  class HashProtocol {
    static SEPARATOR = ':';
    
    // Parse hash into structured data
    static parse(hash) {
      if (!hash) {
        // Empty hash means 'default' project
        return {
          projectId: 'default',
          resourceId: null
        };
      }
      
      // Remove leading #
      hash = hash.startsWith('#') ? hash.slice(1) : hash;
      
      // Split by separator
      const [projectId, resourceId] = hash.split(HashProtocol.SEPARATOR);
      
      return {
        projectId: projectId || 'default', // Empty projectId also means 'default'
        resourceId // null if not present
      };
    }
    
    // Create hash string from parts
    static create(projectId, resourceId = null) {
      // Don't create hash for default project without resource
      if (projectId === 'default' && !resourceId) {
        return '';
      }
      
      let hash = projectId;
      if (resourceId) {
        hash += HashProtocol.SEPARATOR + resourceId;
      }
      
      return hash;
    }
  }

  // Store the hash handler when initializing
  let hashHandler;

  /*********************************************************************
   *            INICIALIZA√á√ÉO
   *********************************************************************/
  async function init() {
    // Load initial data from localStorage
    loadFromLocalStorage();
    loadMetaState();
    renderAll();
    // Initialize hash handling after initial data is loaded
    hashHandler = initHashPlaceHandling();
  }

  // Call init and handle any errors
  init().catch(error => {
    console.error('Initialization error:', error);
  });

  // Add this to help debug
  window.addEventListener('load', () => {
    console.log('After load - selectedTaskId:', selectedTaskId);
    console.log('localStorage selection:', localStorage.getItem(LS_SELECTION_KEY));
  });

  // Add this function to clean up the data structure
  function cleanupDataStructure(tasks) {
    const now = Date.now();
    
    function cleanTask(task) {
      // Create new object with only necessary properties
      const cleaned = {
        id: task.id,
        text: task.text,
        modified: task.modified || now  // Ensure modified always exists
      };
      
      // Only add parentId if not at root
      if (task.parentId) {
        cleaned.parentId = task.parentId;
      }
      
      // Only add children if they exist and not empty
      if (task.children?.length > 0) {
        cleaned.children = task.children.map(cleanTask);
        // Preserve collapsed state
        if (task.collapsed) {
          cleaned.collapsed = true;
        }
      }
      
      // Only add status if not 'seed'
      if (task.status && task.status !== 'seed') {
        cleaned.status = task.status;
      }
      
      return cleaned;
    }
    
    return tasks.map(cleanTask);
  }

  // Update drag handlers to use meta state
  function handleDragStart(e, taskId) {
    metaState.draggingItemId = taskId;
    draggingItemId = taskId;
    saveMetaState();
  }

  function handleDragEnd(e) {
    metaState.draggingItemId = null;
    draggingItemId = null;
    saveMetaState();
    // Clear any stuck hover states
    document.querySelectorAll('.drag-hover').forEach(el => el.classList.remove('drag-hover'));
  }

  // Update selection handlers
  function updateSelection(taskId) {
    selectedTaskId = taskId;
    metaState.selectedTaskId = taskId;
    saveMetaState();
  }

  // Update draft text handler
  function updateDraftText(text) {
    draftText = text;
    metaState.draftText = text;
    saveMetaState();
  }

  // Update status handling to reflect child states
  function getEffectiveStatus(taskId) {
    const task = taskMap[taskId];
    if (!task) return 'seed';
    
    // If it has no children, use its own status
    if (!task.children?.length) {
      return task.status || 'seed';
    }
    
    // Get all child statuses
    const childStatuses = task.children.map(child => getEffectiveStatus(child.id));
    
    // Priority order (most critical first)
    const priorityOrder = ['needs-water', 'under-sun', 'blooming', 'harvest', 'dormant', 'pruned', 'seed'];
    
    // Return the highest priority status found in children
    for (const status of priorityOrder) {
      if (childStatuses.includes(status)) {
        return status;
      }
    }
    
    return 'seed';
  }

  /*********************************************************************
   *                      HASH PROTOCOL HANDLER
   *********************************************************************/
  function initHashPlaceHandling() {
    let lastProjectId = null;
    let lastResourceId = null;

    async function loadFromHash() {
      const hash = window.location.hash.slice(1);
      const context = HashProtocol.parse(hash);
      
      // If no context, use 'default' project
      const projectId = context?.projectId || 'default';
      
      // Only reload project data if project ID changes
      if (projectId !== lastProjectId) {
        // First try to load from localStorage
        const projectData = await DataSource.load(projectId);
        if (projectData) {
          tasks = projectData;
        } else {
          // If no data, use what's already in localStorage
          loadFromLocalStorage();
        }
        
        rebuildTaskMap(tasks);
        currentProjectId = projectId;
        lastProjectId = projectId;
        renderAll();
      }
      
      // Handle dialog visibility
      if (context?.resourceId !== lastResourceId) {
        if (context?.resourceId && taskMap[context.resourceId]) {
          renderContextDialog(context.resourceId);
        }
        lastResourceId = context?.resourceId;
      }
    }

    // Handle hash changes
    window.addEventListener('hashchange', (e) => {
      loadFromHash();
    }, false);
    
    // Initial load
    loadFromHash();
  }

  function renderContextDialog(taskId) {
    const task = taskMap[taskId];
    if (!task) return;

    // Remove existing dialog if any
    const existingDialog = document.querySelector('.dialog-backdrop');
    if (existingDialog) {
      existingDialog.remove();
    }

    // Create backdrop
    const backdrop = document.createElement('div');
    backdrop.className = 'dialog-backdrop';
    backdrop.onclick = (e) => {
      if (e.target === backdrop) {
        backdrop.remove();
        window.location.hash = currentProjectId;
      }
    };

    // Create dialog
    const dialog = document.createElement('div');
    dialog.className = 'context-dialog';

    // Header with close button
    const header = document.createElement('div');
    header.className = 'dialog-header';
    
    const title = document.createElement('h2');
    title.textContent = task.text;
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'close-button';
    closeBtn.innerHTML = '√ó';
    closeBtn.onclick = () => {
      backdrop.remove();
      window.location.hash = currentProjectId;
    };

    header.appendChild(title);
    header.appendChild(closeBtn);

    // Content
    const content = document.createElement('div');
    content.className = 'dialog-content';
    
    // Add task details
    const details = document.createElement('div');
    details.innerHTML = `
      <p><strong>ID:</strong> ${task.id}</p>
      <p><strong>Status:</strong> ${task.status || 'seed'}</p>
      <p><strong>Modified:</strong> ${new Date(task.modified).toLocaleString()}</p>
      ${task.parentId ? `<p><strong>Parent:</strong> ${taskMap[task.parentId]?.text || 'Unknown'}</p>` : ''}
      ${task.children?.length ? `<p><strong>Children:</strong> ${task.children.length}</p>` : ''}
    `;
    
    content.appendChild(details);

    // Assemble dialog
    dialog.appendChild(header);
    dialog.appendChild(content);
    backdrop.appendChild(dialog);
    
    // Add to document
    document.body.appendChild(backdrop);
  }
</script>

</body>
</html>

